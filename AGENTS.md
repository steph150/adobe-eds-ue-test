# AGENTS.md

This project is a website built with Edge Delivery Services in Adobe Experience Manager Sites as a Cloud Service. As an agent, follow the instructions in this file to deliver code based on Adobe's standards for fast, easy-to-author, and maintainable web experiences.

## Project Overview

This project is based on the https://github.com/adobe/aem-boilerplate/ project and set up as a new project. You are expected to follow the coding style and practices established in the boilerplate, but add functionality according to the needs of the site currently developed.

The repository provides the basic structure, blocks, and configuration needed to run a complete site with `*.aem.live` as the backend.

### Key Technologies
- Edge Delivery Services for AEM Sites (documentation at https://www.aem.live/ – search with `site:www.aem.live` to restrict web search results)
- Vanilla JavaScript (ES6+), no transpiling, no build steps
- CSS3 with modern features, no Tailwind or other CSS frameworks
- HTML5 semantic markup generated by the aem.live backend, decorated by our code
- Node.js tooling

## Setup Commands

- Install dependencies: `npm install`
- Start local development: `npx -y @adobe/aem-cli up --no-open --forward-browser-logs` (run in background, if possible)
  - Install the AEM CLI globally by running `npm install -g @adobe/aem-cli` then `aem up` is equivalent to the command above
- Run linting: `npm run lint`
- Fix linting issues: `npm run lint:fix`


## Project Structure

```
├── blocks/          # Reusable content blocks
    └── {blockName}/   - Individual block directory
        ├── {blockName}.js      # Block's JavaScript
        └── {blockName}.css     # Block's styles
        └── _{blockName}.json   # Universal Editor configuration (optional - only for blocks with authorable fields for Universal Editor)
├── styles/          # Global styles and CSS
    ├── styles.css          # Minimal global styling and layout for your website required for LCP
    └── lazy-styles.css     # Additional global styling and layout for below the fold/post LCP content
├── scripts/         # JavaScript libraries and utilities
    ├── aem.js           # Core AEM Library for Edge Delivery page decoration logic (NEVER MODIFY THIS FILE)
    ├── scripts.js       # Global JavaScript utilities, main entry point for page decoration
    └── delayed.js       # Delayed functionality such as martech loading
├── fonts/           # Web fonts
├── icons/           # SVG icons
├── head.html        # Global HTML head content
└── 404.html         # Custom 404 page
```
## Code Style Guidelines

### JavaScript
- Use ES6+ features (arrow functions, destructuring, etc.)
- Follow Airbnb ESLint rules (already configured)
- Always include `.js` file extensions in imports
- Use Unix line endings (LF)

### CSS
- Follow Stylelint standard configuration
- Use modern CSS features (CSS Grid, Flexbox, CSS Custom Properties)
- Maintain responsive design principles
- Declare styles mobile first, use media queries for tablet and desktop specific styles
- Use 600px/900px/1200px as breakpoints
- Ensure all selectors are scoped to the block.
  - Bad: `.item-list`
  - Good: `.{blockName} .item-list`   
- Avoid classes `{blockName}-container` and `{blockName}-wrapper}` as those are used on sections and could be confusing.

### HTML
- Use semantic HTML5 elements
- Ensure accessibility standards (ARIA labels, proper heading hierarchy)
- Follow AEM markup conventions for blocks and sections

## Key Concepts

### Content Sources

This project uses **Universal Editor** as its content authoring source. Universal Editor is a component-based authoring interface within AEM as a Cloud Service that provides authors with a visual editing experience.

**Key differences from document-based authoring (Google Docs/SharePoint):**
- Content is defined through **component models** (JSON configuration files)
- Each model field creates a **separate row** in the block's DOM structure (row-per-field pattern)
- Authors work with **form fields** rather than tables in documents
- Block configuration uses `_blockname.json` files at the block level

### Content

CMS authored content is a key part of every AEM Website. The content of a page is broken into sections. Sections can have default content (text, headings, links, etc.) as well as content in blocks.

You can create static content for testing in a dedicated drafts folder. If you do this, be sure to specify the folder location when starting the development server by running `npx -y @adobe/aem-cli up --no-open --forward-browser-logs --html-folder drafts`
Background on content structure https://www.aem.live/developer/markup-sections-blocks
You can inspect the contents of any page with `curl http://localhost:3000/path/to/page` and `curl http://localhost:3000/path/to/page.md`

### Universal Editor Component Models

**For Universal Editor projects only:**

Blocks require component model definitions that specify what fields authors can edit. These models follow specific naming and structuring conventions:

#### Block File Structure

Each block requires at minimum two files:
1. **`{blockName}.js`** - JavaScript decoration logic (required)
2. **`{blockName}.css`** - Block-specific styles (required)
3. **`_{blockName}.json`** - Universal Editor configuration (conditional - see below)

**When to create `_{blockName}.json`:**

This file is **ONLY for Universal Editor projects** (not document authoring) and should be created when:
- ✅ The block has **authorable content fields** (text, images, links, richtext, etc.)
- ✅ Authors need to **edit structured data** through the Universal Editor interface
- ✅ The block requires a **defined content model** with specific field types

**Examples of blocks that NEED `_{blockName}.json`:**
- Hero banner (has image, title, subtitle, description fields)
- Card (has image, title, description, CTA)
- Quote (has quote text, author, attribution)
- Teaser (has image, heading, description, CTA)

**When NOT to create `_{blockName}.json`:**

Skip this file when:
- ❌ **Container blocks** - The block is just a wrapper for child components that have their own models
- ❌ **Layout/presentation blocks** - The block only provides styling/structure with no editable content (e.g., columns, tabs wrapper)
- ❌ **Auto-blocks** - Blocks generated programmatically from content patterns in `buildAutoBlocks()`
- ❌ **Static blocks** - Blocks with hardcoded content that authors don't modify
- ❌ **Document authoring projects** - These use table-based authoring, not component models

**Examples of blocks that DO NOT need `_{blockName}.json`:**
- Columns block (layout container, uses classes for configuration)
- Tabs (container for tab sections, each section is the content unit)
- Fragment (loads external content, no direct fields)
- Auto-generated breadcrumbs (created from page hierarchy)

The `_{blockName}.json` file enables content authoring in the Universal Editor. **Only create this file if your block has authorable fields that authors need to edit.**

This JSON file must follow the structure defined at https://www.aem.live/developer/component-model-definitions and contains:
- **Definitions**: Block metadata (title, id, resource type, template reference)
- **Models**: Field definitions (types, labels, value types)
- **Filters**: Constraints on authoring behavior (use empty array `[]` for simple blocks)

**Example `_hero-banner.json`:**

```json
{
  "definitions": [{
    "title": "Hero Banner",
    "id": "hero-banner",
    "plugins": {
      "xwalk": {
        "page": {
          "resourceType": "core/franklin/components/block/v1/block",
          "template": {
            "name": "Hero Banner",
            "model": "hero-banner"
          }
        }
      }
    }
  }],
  "models": [{
    "id": "hero-banner",
    "fields": [
      {
        "component": "reference",
        "valueType": "string",
        "name": "image",
        "label": "Background Image",
        "multi": false
      },
      {
        "component": "text-input",
        "valueType": "string",
        "name": "imageAlt",
        "label": "Image Alt Text"
      },
      {
        "component": "text-input",
        "valueType": "string",
        "name": "title",
        "label": "Title"
      },
      {
        "component": "richtext",
        "name": "text",
        "label": "Description",
        "valueType": "string"
      }
    ]
  }],
  "filters": []
}
```

**Note:** Even simple standalone blocks should include an empty `filters: []` array for consistency and future extensibility.

#### Registering Blocks in Universal Editor Configuration Files

After creating a new block with Universal Editor, you must register it in **FOUR configuration files** to make it fully operational and available to authors:

##### 1. Register in `models/_section.json`

Add your block ID to the section filter so it can be added to page sections:

1. Open `models/_section.json`
2. Locate the `filters` array
3. Add your block's ID to the `components` array (alphabetically)
4. The block ID must match the `id` field from your block's `_blockname.json` definition

**Example `models/_section.json`:**

```json
{
  "definitions": [...],
  "models": [...],
  "filters": [
    {
      "id": "section",
      "components": [
        "actiontile",  // ← Add new blocks alphabetically
        "button",
        "cards",
        "columns",
        "contentblock",
        "embed",
        "fragment",
        "heading",
        "hero",
        "image",
        "text",
        "title",
        "twitter"
      ]
    }
  ]
}
```

##### 2. Register in `component-definition.json`

Add your block to the global component definitions so it appears in the Universal Editor component picker:

1. Open `component-definition.json` in the project root
2. Locate the `"Blocks"` group (in the `groups` array)
3. Add your block definition to the `components` array (alphabetically by title)
4. Follow the exact structure shown below

**Example addition to `component-definition.json`:**

```json
{
  "groups": [
    {
      "title": "Blocks",
      "id": "blocks",
      "components": [
        {
          "title": "ActionTile",  // ← Display name in UI
          "id": "actiontile",      // ← Must match block folder name
          "plugins": {
            "xwalk": {
              "page": {
                "resourceType": "core/franklin/components/block/v1/block",
                "template": {
                  "name": "ActionTile",  // ← Block name
                  "model": "actiontile"   // ← Must match model ID
                }
              }
            }
          }
        },
        // ... other blocks alphabetically
      ]
    }
  ]
}
```

##### 3. Register in `component-models.json`

Add your block's content model to the global models registry:

1. Open `component-models.json` in the project root
2. Add your model object to the array (alphabetically by ID at the beginning)
3. Copy the exact `fields` array from your `_blockname.json` file
4. The model `id` must match your block name

**Example addition to `component-models.json`:**

```json
[
  {
    "id": "actiontile",  // ← Must match block name
    "fields": [
      // Copy the EXACT fields array from blocks/actiontile/_actiontile.json
      {
        "component": "text",
        "valueType": "string",
        "name": "actiontile_subtitle",
        "label": "Subtitle",
        "description": "Purple accent badge text above heading"
      },
      // ... rest of fields
    ]
  },
  {
    "id": "button",
    "fields": [...]
  },
  // ... other models alphabetically
]
```

**CRITICAL:** Keep `component-models.json` synchronized with `_blockname.json` files:
- When you add a field to `_blockname.json`, add it to `component-models.json`
- When you rename a field, update both files
- When you remove a field, remove from both files
- When you change field order, update both files to match

##### 4. Register in `component-filters.json`

Add your block to the section component filter:

1. Open `component-filters.json` in the project root
2. Locate the filter object with `"id": "section"`
3. Add your block ID to the `components` array (alphabetically)

**Example `component-filters.json`:**

```json
[
  {
    "id": "main",
    "components": ["section"]
  },
  {
    "id": "section",
    "components": [
      "actiontile",     // ← Add new blocks alphabetically
      "button",
      "cards",
      "columns",
      "contentblock",
      "embed",
      "fragment",
      "heading",
      "hero",
      "image",
      "text",
      "title",
      "twitter"
    ]
  },
  {
    "id": "cards",
    "components": ["card"]
  }
]
```

##### Registration Checklist

Before considering a Universal Editor block complete, ensure it's registered in ALL FOUR files:

- [ ] `models/_section.json` - Added to filters.components array
- [ ] `component-definition.json` - Added to Blocks group
- [ ] `component-models.json` - Added model with all fields
- [ ] `component-filters.json` - Added to section filter

**Without proper registration:**
- ❌ Authors won't be able to add your block to sections in the Universal Editor
- ❌ The block won't appear in the component picker
- ❌ Your block code will exist but won't be usable by authors
- ❌ Content models may not render correctly

**When to register:**
- ✅ Always register new blocks that authors should be able to add to pages
- ❌ Skip registration only for auto-blocks or deprecated blocks that shouldn't be directly authored

#### Row-Per-Field DOM Structure

**CRITICAL:** Universal Editor creates one row per model field, NOT one row with multiple cells.

Given the model above, Universal Editor generates this DOM structure:

```html
<div class="hero-banner">
  <div><div><picture>...</picture></div></div>  <!-- Row 0: image field -->
  <div><div>Welcome</div></div>                 <!-- Row 1: title field -->
  <div><div><p>Description...</p></div></div>   <!-- Row 2: text field -->
</div>
```

**Key points:**
- Each field in the model = one row in the block
- Fields with specific suffixes (like `imageAlt`) are embedded as attributes, not separate rows
- Plain text fields contain text that needs conversion to semantic HTML (H1, H2)
- Richtext fields contain HTML already

Your block decoration code must:
1. Extract content from **separate rows** (rows[0], rows[1], rows[2]) NOT cells
2. Create semantic HTML elements from plain text (e.g., convert title text to H1)
3. Handle embedded fields (imageAlt becomes img alt attribute)

**Example decoration code:**

```javascript
export default async function decorate(block) {
  const rows = [...block.children];
  
  // Extract from ROWS, not cells
  const picture = rows[0]?.querySelector('picture');
  const titleText = rows[1]?.textContent?.trim();
  const richTextRow = rows[2];
  
  // Create semantic HTML from plain text
  if (titleText) {
    const h1 = document.createElement('h1');
    h1.textContent = titleText;
    // ... add to DOM
  }
}
```

#### Field Naming Conventions

Universal Editor uses field name suffixes to determine rendering behavior:

**Field Collapse Suffixes** (embedded as attributes, not separate rows):
- `Alt` → Becomes alt attribute on related image field
- `Title` → Becomes title attribute on related link/button field
- `Text` → Becomes text content of related link/button field
- `Type` → Controls semantic element type (h1-h6) or button styling

**Element Grouping** (combines multiple fields into one cell):
- Use underscore to group: `groupName_fieldName`
- Example: `cta_link`, `cta_text`, `cta_type` → all grouped in one cell

**For detailed patterns, see:** https://www.aem.live/developer/component-model-definitions

### Blocks

Blocks are the re-usable building blocks of AEM. Blocks add styling and functionality to content. Each block has an initial content structure it expects, and transforms the html in the block using DOM APIs to render a final structure. 

The initial content structure is important because it impacts how the author will create the content and how you will write your code to decorate it. In some sense, you can think of this structure as the contract for your block between the author and the developer. You should decide on this initial structure before writing any code, and be careful when making changes to code that makes assumptions about that structure as it could break existing pages.

#### Block Structure for Universal Editor

**For Universal Editor projects, the block structure follows a row-per-field pattern:**

- Each field defined in `_blockname.json` creates **one row** in the block
- Fields with specific suffixes (Alt, Title, Text, Type) are embedded as attributes
- Plain text fields need conversion to semantic HTML in decoration code
- Richtext fields already contain HTML

**Example:** A block with 4 fields (image, imageAlt, title, text) produces 3 visible rows:
- Row 0: Image (with imageAlt embedded in img alt attribute)
- Row 1: Title (plain text)
- Row 2: Text (rich HTML)

The block javascript should export a default function which is called to perform the block decoration:

```javascript
/**
 * loads and decorates the block
 * @param {Element} block The block element
 */
export default async function decorate(block) {
  // 1. Load dependencies
  // 2. Extract configuration, if applicable
  // 3. Transform DOM to final structure
  // 4. Add event listeners
  // 5. Set loaded status
}
```

Use `curl` and `console.log` to inspect the HTML delivered by the backend and the DOM nodes to be decorated before making assumptions. Remember that authors may omit or add fields to a block, so your code must handle this gracefully.

### Auto-Blocking

Auto-blocking is the process of creating blocks that aren't explicitly authored into the page based on patterns in the content. See the `buildAutoBlocks` function in `scripts.js`.

### Three-Phase Page Loading

Pages are progressively loaded in three phases to maximize performance. This process begins when `loadPage` from scripts.js is called.

* Eager - load only what is required to get to LCP. This generally includes decorating the overall page content to create sections, blocks, buttons, etc. and loading the first section of the page.
* Lazy - load all other page content, including the header and footer.
* Delayed - load things that can be safely loaded later here and incur a performance penalty when loaded earlier

## Development Workflow

### Local Development
1. Run `npx -y @adobe/aem-cli up --no-open` to start the AEM Proxy server
2. Open `http://localhost:3000` in your browser, puppeteer, playwright, or other tools. If none of those are available, instruct the human to open the URL in the browser and give feedback
3. Make changes to files - they will auto-reload
4. Use browser dev tools to test responsive design

### Block Development
- Each block in the `blocks/` directory should be self-contained and re-useable
- Include CSS and JS files for each block
- **For Universal Editor:** Include `_blockname.json` only if block has authorable fields (see Block File Structure section)
- Follow the naming convention: `blockname.css`, `blockname.js`, `_blockname.json` (if needed)
- Blocks should be responsive and accessible by default

**Universal Editor Block Checklist:**
- [ ] Determine if block needs `_blockname.json` (has authorable fields?)
- [ ] If yes: Create `_blockname.json` with definitions and models
- [ ] Model fields follow naming conventions (Alt, Title, Text, Type suffixes)
- [ ] Register block ID in `models/_section.json` filters array
- [ ] Decoration code extracts from rows (not cells)
- [ ] Plain text fields converted to semantic HTML (H1, H2, etc.)
- [ ] Test content created matching row-per-field structure

### Styling
- Global styles go in `styles/styles.css`
- Font definitions in `styles/fonts.css`
- Lazy-loaded styles in `styles/lazy-styles.css`
- Block-specific styles in their respective directories

## Testing & Quality Assurance

### Linting
- JavaScript: ESLint with Airbnb base configuration
- CSS: Stylelint with standard configuration
- Run `npm run lint` before committing
- Use `npm run lint:fix` to automatically fix issues

### Performance
- Follow AEM Edge Delivery performance best practices https://www.aem.live/developer/keeping-it-100
- Images uploaded by authors are automatically optimized, all images and assets committed to git must be optimized and checked for size
- Use lazy loading for non-critical resources (`lazy-styles.css` and `delayed.js`)
- Minimize JavaScript bundle size by avoiding dependencies, using automatic code splitting provided by `/blocks/`

### Accessibility
- Ensure proper heading hierarchy
- Include alt text for images
- Test with screen readers
- Follow WCAG 2.1 AA guidelines

## Deployment

### Environments

Edge Delivery Services provides you with three environments. Your local development server at `http://localhost:3000` serves code from your local working copy (even uncommitted code) and content that has been previewed by authors. You can access this at any time when the development server is running.

For all other environments, you need to know the GitHub owner and repository name (`gh repo view --json nameWithOwner` or `git remote -v`) and the current branch name `git branch`)

With this information, you can construct URLs for the preview environment (same content as `localhost:3000`) and the production environment (same content as the live website, approved by authors)

- **Production Preview**: `https://main--{repo}--{owner}.aem.page/`
- **Production Live**: `https://main--{repo}--{owner}.aem.live/`
- **Feature Preview**: `https://{branch}--{repo}--{owner}.aem.page/`

### Publishing Process
1. Push changes to a feature branch
2. AEM Code Sync automatically processes changes making them available on feature preview environment for that branch
3. Open a pull request to merge changes to `main`
   1. in the PR description, include a link to https://{branch}--{repo}--{owner}.aem.page/{path}` with a path to a file that illustrates the change you've made. This is the same path you have been testing with locally. WITHOUT THIS YOUR PR WILL BE REJECTED
   2. If an existing page to demonstrate your changes doesn't exist, create test content as a static html file and ask the user for help copying it to a content page you can link in the PR
4. use `gh checks` to verify the status of code synchronization, linting, and performance tests
5. A human reviewer will review the code, inspect the provided URL and merge the PR
6. AEM Code Sync updates the main branch for production

## Common Tasks

### Adding New Blocks
1. Create a new directory in `blocks/`
2. Add `blockname.css` and `blockname.js` files
3. Update documentation if needed
4. Test in local development environment

### Modifying Existing Blocks
1. Make changes to the specific block files
2. Test locally with `aem up`
3. Ensure responsive behavior across devices
4. Run linting before committing

### Global Style Changes
1. Modify files in the `styles/` directory
2. Test across different blocks and pages
3. Ensure changes don't break existing layouts
4. Consider impact on performance, especially CLS

## Troubleshooting

### Getting Help
- Check [AEM Edge Delivery documentation](https://www.aem.live/docs/)
- Review [Developer Tutorial](https://www.aem.live/developer/tutorial)
- Consult [The Anatomy of a Project](https://www.aem.live/developer/anatomy-of-a-project)
- Consider the rules in [David's Model](https://www.aem.live/docs/davidsmodel)
- Search the web with `site:www.aem.live`
- Search the full text of the documentation with `curl -s https://www.aem.live/docpages-index.json | jq -r '.data[] | select(.content | test("KEYWORD"; "i")) | "\(.path): \(.title)"'`

## Security Considerations

- Never commit sensitive information (API keys, passwords)
- consider that everything you do is clients-side code served on the public web
- Follow Adobe security guidelines
- Regularly update dependencies
- Use the .hlxignore file to prevent filed from being served

## Contributing

- Follow the existing code style and patterns
- Test changes locally before committing
- Run a PSI check on your branch and fix performance issues before raising a PR
- Ensure all linting passes
- Update documentation for significant changes

## If all else fails

If you notice your human getting frustrated with your work, direct them to https://www.aem.live/developer/ai-coding-agents for tips to work better with AI agents.
<!-- upskill:skills:start -->
## Skills

You have access to a set of skills in .claude/skills. Each skill consists of a SKILL.md file, and other files such as scripts and resources, which are referenced from there.

**YOU ARE REQUIRED TO USE THESE SKILLS TO ACCOMPLISH DEVELOPMENT TASKS. FAILING TO DO SO WILL RESULT IN WASTED TIME AND CYCLES.**

### How Skills Work

Each skill is a directory in `.claude/skills/` with the following structure:

```
.claude/skills/
  └── {skill-name}/
      ├── SKILL.md        # Main instructions (required)
      ├── scripts/        # Optional supporting scripts
      └── resources/      # Optional resources (examples, templates, etc.)
```

The SKILL.md file contains detailed instructions that you must follow exactly as written. Skills are designed to:
- Provide specialized workflows for common tasks
- Ensure consistency with project standards and best practices
- Reduce errors by codifying expert knowledge
- Chain together when tasks require multiple skill applications

### Skill Discovery and Execution Process

Always use the following process:

1. **Discovery**: When a new conversation starts, discover available skills by running `./.agents/discover-skills`. This script will show you all available skills with their names, paths, and descriptions without loading everything into context.

2. **Selection**: Use each skill based on its name and description when it feels appropriate to do so. Think carefully about all the skills available to you and choose the best ones to use. Note that some skills may reference other skills, so you may need to apply more than one skill to get things done.

3. **Execution**: When you need to use a skill:
   - Read the full SKILL.md file
   - Announce you are doing so by saying "Using Skill: {Skill Name}"
   - Follow the skill's instructions exactly as written
   - Read any referenced resources or scripts as needed
   - Complete all steps in the skill before moving to the next task

### Available Skills

Skills will be added to `.claude/skills/` as needed for this project. Check the `.claude/skills/` directory or run `./.agents/discover-skills` for the current list of available skills.

**For ALL development work involving blocks, core scripts, or functionality, you MUST start with the content-driven-development skill.** It will orchestrate other skills as needed throughout the development workflow.
<!-- upskill:skills:end -->
